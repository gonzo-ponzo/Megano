# API payment

## добавить счет на оплату - POST-запрос такого вида:
    url = reverse("one_payment", args=[<номер_счета>])
    data = {"card_number": "<номер_карты>", "sum_to_pay": <сумма_к_оплате>}
    response = self.client.post(url, data)

Параметры:
* <номер_счета> - целое число
* <номер_карты> - число либо строка из цифр с пробелами (валидацию пройдет, если в номере будет не больше восьми цифр, номер четный и не оканчивается на ноль)
* <сумма_к_оплате> - число либо строка (положительное действительное число, не больше двух знаков после запятой)

Возвращается либо json с полями ["order_number", "status", "status_text"], если счет успешно поставлен в очередь. Либо json с ключом "error", если в очереди уже есть счет с таким же номером, новый либо оплаченный.

## проверить статус счета - GET-запрос:
    url = reverse("one_payment", args=[<номер_счета>])
    response = self.client.get(url)
Возвращается либо json с полями ["order_number", "status", "status_text"], если запись об искомом счете есть в очереди, либо json с ключом "error".

### Статусы платежей
* 0 - новый платеж
* 1 - оплата успешна
* 2,3,4 и выше - платеж не прошел, по какой-либо причине

---
# CELERY для обработки платежей

В requirements новые пакеты, в payment/fixtures - файл с задачей в расписании celery.
В docker-compose настройки для двух контейнеров с процессами celery - worker и beat.

Для запуска обработчика событий ничего дополнительно запускать не требуется. Вот [тут](http://127.0.0.1:8000/admin/django_celery_beat/periodictask/) должна быть активная задача на выполнение.

Для экспериментов - добавлять новые записи [тут](http://127.0.0.1:8000/admin/payment/payment/), и смотреть как celery будет им статусы менять.

